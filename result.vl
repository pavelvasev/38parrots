import components.creative_points 1.0
import "./public"

Scene2 {
    
    id: scene_obj


    ///////////////// params api
    
    property var afile: param_emachine_afile
    
    ///////////////// params api done
    
    property var setup_info: log_5.output /* moved to singletones */
    text: "Сцена"
    DataParam {
        
        id: param_emachine_afile
    
        text: 'afile'
        values: [resolved_7.output /* by qml-xtract.cm2 */]
        multiple: true
        property var val: files
    
        Item {
            //generated by auto_qml_obj
            id: resolved_7
        
            property var output: func_resolved( input_0 )
            property var input_0: './examples/1-running-point.cdb/data.csv'
        }
    }
    
    CinemaParams {
        
        id: param_emachine_cinema_params
    
        input: parse_csv_3.output /* moved to singletones, second use */
    }
    
    ExtrasBridge {
        
        id: obj_0
    
        cinemaViews: cinema_views
        masterExtrasManager: local_extras_manager
    }
    
    CinemaViews {
        
        id: cinema_views
    
        artefact_col_names: param_emachine_cinema_params.artefact_col_names
        artefacts: generate_artefact_paths_10.output /* moved to singletones, second use */
    }
    
    function combine_arrays () {
      
        // ну упаковка.. дали набор одномерных массивов - выдай из них сборку, один массив во viewlang-упаковке
        // todo можно сделать ускоренную версию для 3х входов - var arr1=arguments[0]; и т.д.
        for (var i=0; i<arguments.length; i++,index++)
          if (typeof(arguments[i]) == "undefined") return []; // ну такая защита.. если какой-то аргумент-массив еще не рассчитался.. (бывали случаи)
        
        var len1 = arguments[0].length;
        var acc = new Float32Array(len1 * arguments.length);
        var index = 0;
        for (var line=0; line<len1; line++)
          for (var i=0; i<arguments.length; i++,index++)
            acc[index] = ( arguments[i][line] || 0 );
    
        return acc;
    
    }
    
    ///////////////// singletones!
    
    Item {
        //generated by auto_qml_obj
        id: find_datacsv_1
    
        property var output: func_find_datacsv( input_0 )
        property var input_0: param_emachine_afile.val
    }
    
    Item {
        //generated by auto_qml_obj
        id: parse_csv_3
    
        property var output: func_parse_csv( input_0 )
        property var input_0: obj_1.output /* by qml-xtract.cm2 */
    
        TextLoader2 {
            
            id: obj_1
        
            property var input_0: resolved_2.output /* by qml-xtract.cm2 */
        
            Item {
                //generated by auto_qml_obj
                id: resolved_2
            
                property var output: func_resolved( input_0 )
                property var input_0: find_datacsv_1.output /* moved to singletones */
            }
        }
    }
    
    Item {
        //generated by auto_qml_obj
        id: log_5
    
        property var output: func_log( input_0 )
        property var input_0: extract_part_hitro_4.output /* by qml-xtract.cm2 */
    
        Item {
            //generated by auto_qml_obj
            id: extract_part_hitro_4
        
            property var output: func_extract_part_hitro( input_0,input_1,input_2,input_3 )
            property var input_0: parse_csv_3.output /* moved to singletones */
            property var input_1: "*"
            property var input_2: 0
            property var input_3: "colnames"
        }
    }
    
    Item {
        //generated by auto_qml_obj
        id: generate_artefact_paths_10
    
        property var output: []
        property var input_0: param_emachine_cinema_params.artefacts
        property var input_1: makedict_8.output /* by qml-xtract.cm2 */
        property var input_2: basepath_9.output /* by qml-xtract.cm2 */
        DeferredCalc {
            
            id: obj_2
        
            targetProperty: "output"
            func: func_generate_artefact_paths
            params: [parent.input_0,parent.input_1,parent.input_2]
        }
    
        Item {
            //generated by auto_qml_obj
            id: makedict_8
        
            property var output: func_makedict( input_0 )
            property var input_0: param_emachine_afile.val
        }
        
        Item {
            //generated by auto_qml_obj
            id: basepath_9
        
            property var output: func_basepath( input_0 )
            property var input_0: find_datacsv_1.output /* moved to singletones, second use */
        }
    }
    
    /////////////// runtime extras!
    
    property var external_extras_manager: new Object({output:[]})
    property var final_extras_arr: external_extras_manager.output.concat( local_extras_manager.output )
    property var local_extras_manager: obj_extras_manager
    ExtrasManager {
        
        id: obj_extras_manager
    
        title: scene_obj.isRoot ? 'Добавки' : scene_obj.text+'&nbsp;-&nbsp;Добавки'
        input_1: []
    }
    
    sceneconf: '{"params":{"show_axes":1}}'
    
    ///////////////// functions!
    
    function func_find_datacsv (arr) {
      var qq = function(arr) {
       for (var i=0; i<arr.length; i++) {
          if (arr[i].name && arr[i].name == "data.csv") return arr[i] ;
          if (arr[i].match && arr[i].match("data.csv")) return arr[i];
       }
       return "";
      }
      var res = qq( arr );
      if (typeof(res) == "string") res = Qt.resolvedUrl( res ); // вот еще как
      console.log( "find_datacsv: res=",res);
      /* ЛаднО, у меня реально сомнения, стоит ли это сейчас здесь делать. Может и стоит, но это надо разобрать отдельно.
         Потому что возможно реально стоит создать на уровне выше систему.
      if (res == "") {
        // вот здесь можно сделать авто-генерацию csv-файла.. но я не буду
        // потому что моя новая максима говорит мне, что если из вещи можно что-то выкинуть, то надо выкинуть
        // с другой стороны - а что мы делаем? просмотрщик? просмотрщик чего? синема файла? или синема-файла и всего чего только можно?
        // вообще по уму - только синема-файла. Потому что не-синема это мы сделаем потом, с воркспейсами когда заморочимся..
        // но конечно интересно попробовать хотя бы..
        var autogenerate = function( arr ) {
          var count = 0;
          var names = { autoN: 1 };
          var res = { autoN: [] };
          
          var fname1 = arr[0].name;
          var extname = fname1.substring( fname1.lastIndexOf(".")+1 );
          var colname = "FILE_"+extname+"_auto";
          // ну сделаем по-простому: всех в ряд.
          res[colname] = [];
          
          for (var i=0; i<arr.length; i++) {
            res[colname].push( arr[i] );
            res['autoN'].push( i );
          }
          
          res.colnames = ["autoN",colname];
          res = { 'blob' : res }
          return res;
        }
        
        console.log("res is empty, generating");
        res = autogenerate( arr );
        console.log("generated",res );
      }
      */
      ///console.log(arr);
      //return arr[0];
      return res;
    }
    function func_resolved (u) {
      if (Array.isArray(u)) return Qt.resolvedUrl( u[0] );
      
     return Qt.resolvedUrl( u );
    }
    function func_parse_csv (data,separator) { // data is text blob
      var lines = data.split("\n"); 
      console.log("lines=",lines.length)
    /* ну вот что она делает.. ну парсит таблицу.. выдает массивчег.. из массивчегов.. ну хоть так для начала
       а дальше.. а дальше нам надо создать из этой штуки поле..
    */
       var trim1 = function (str) {
         return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
       }
       
       var splittrim = function( str,sep ) {
         return str.split( sep ).map( function(e) { return e.trim(); } );
       }
    
       var filter = function ( item ) {
         return parseFloat( item );
       }
    
       var skip="";
      // if (typeof(separator)=="undefined") separator="(\\s|,)";
       if (typeof(separator)=="undefined") separator=","; // чето второй раз сепаратор в csv мне попался запятая )))
    
       var separator_rx = new RegExp( separator + "+" );
       console.log("using separator:",separator_rx );
    
       proj_names = splittrim( lines[0], separator_rx );
       var acc = [];
    
        for (var i=1; i<lines.length; i++) {
          var line = trim1( lines[i] );
          if (skip.length > 0 && line.indexOf(skip) >= 0) continue;
    
          if (line.length == 0) continue;
    
          //var s = line.split(/\s+/);
    
          // todo вытаскивать закавыченные данные надо уметь
    
          var attrs = splittrim(line,separator_rx).map( function(item) {
            // хотя.. может быть стоит сделать такую штуку, которая потом уже csv прочитанный таким методом оснащает данными (парсит)
            // float?
            if (/^[+-]?([0-9]*[.])?[0-9]+((e[+-]?\d+)?)$/.test(item)) // https://stackoverflow.com/questions/12643009/regular-expression-for-floating-point-numbers
              return parseFloat( item );
            // date?
            if (/^([12]\d{3}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01]))/.test(item)) // 2019-10-18
              return Date.parse( item );
            if (/^((0[1-9]|[12]\d|3[01])\/(0[1-9]|1[0-2])\/[12]\d{3})/.test(item)) { // 31/04/2015 - но это не обрабатывается date.parse, засим перевернем месяц и год для него, см ниже 
              // гребаные уроды
              var s = item.split("/");
              var s2 = s[1] + "/" + s[0] + "/" + s[2]; // в s[2] окажется и остаток
              return (Date.parse( s2 ) || item);
            }
            if (/^((0[1-9]|[12]\d|3[01])\.(0[1-9]|1[0-2])\.[12]\d{3})/.test(item)) { // 31.04.2015 - но это не обрабатывается date.parse, засим перевернем месяц и год для него, см ниже 
              var s = item.split(".");
              var s2 = s[1] + "/" + s[0] + "/" + s[2]; // в s[2] окажется и остаток
              return (Date.parse( s2 ) || item);
            }        
            return item;
          } );
    
          for (var j=0; j<attrs.length; j++) {
            acc[j] = acc[j] || [];
            acc[j].push( attrs[j] );
          }
        }
          
        var res = {};
        for (var j=0; j<proj_names.length; j++)
          res[ proj_names[j] ] = acc[j];
        // ну кстати оно тут порядок не сохраняет.. а мы (ну Миша) его любим..
        res[ "colnames" ] = proj_names;
    
        //output = revert ? acc.reverse() : acc; -- оставим в качестве памятника тупости некомпозиционности
        return res;
        
        // todo позаниматься загрузкой во флоаты 
        // https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from
        // https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Float32Array
    }
    function func_extract_part_hitro (obj,name,index,realname) {
      if (Array.isArray(obj)) {
         if (name == "*") // сообразно index всегда 0, но зато realname нечто настоящее
           return obj[ parseInt(realname) ];
         else
           return obj[index];
      }
      // ну надеемся что obj это хеш
        
      if (name == "*")
        return obj[realname] || [];
          
      return obj[name] || [];
    }
    function func_log () {
      for (var i=0; i<arguments.length; i++)
        console.log(arguments[i]);
      return arguments;
    }
    function func_makedict (arr) {
      var res = new Object();
      for (var i=0; i<arr.length; i++) {
        if (!arr[i].name) continue;
        res[ arr[i].name ] = arr[i];
      }
      return res;
    }
    function func_basepath (filepath) {
      console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! basepath for ",filepath );
      if (filepath.lastIndexOf)
        return filepath.slice( 0, filepath.lastIndexOf("/")+1 );
      return "";
    }
    function func_generate_artefact_paths (artefacts_arr,input_files,datacsv_basepath) {
      console.log("generate_artefact_paths",artefacts_arr,input_files,datacsv_basepath );
      
      var fix1 = function( item ) {
        if (typeof(item) != "string") {
          console.error("aretfixer::generate_artefact_paths: typeof item is not string",typeof(item),item);
          return "";
        }
        if (item[0] == "/") return item;
        if (item.match(/\w+\:\/\//)) return item; есь :// значит не наш клиент
        if (item[0] == "." && item[1] == "/") item = item.substring( 2 );
        // теперь item это гарантированно - относительный путь безо всяких там ./
        // так, у нас локальные файлы? если да - вернем их
        if (input_files[ item ]) return input_files[ item ];
        // иначе (если даже и локальные файлы но их там нет.. ну вернем чего-нибудь
        return datacsv_basepath + item;
      }
      
      var res= artefacts_arr.map( function(item) { return fix1(item) });
      console.log("res=",res);
      
      /*
      // кряк
      setTimeout( function() {
        output=res;
      }, 5 );
      return output;
      */
      
      return res;
    }
}
