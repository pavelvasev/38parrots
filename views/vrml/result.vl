import "./../../public"

import components.creative_points 1.0
Scene2 {
    
    id: scene_obj


    ///////////////// params api
    
    property var afile: param_emachine_afile
    
    ///////////////// params api done
    
    property var setup_info: []
    text: "VRML"
    DataParam {
        
        id: param_emachine_afile
    
        text: 'afile'
        values: [resolved_2.output /* by qml-xtract.cm2 */]
        multiple: false
        property var val: file
    
        Item {
            //generated by auto_qml_obj
            id: resolved_2
        
            property var output: func_resolved( input_0 )
            property var input_0: "https://viewlang.ru/dubins/data/2-asymm-1pi-8pi/aSymm-100.vrml"
        }
    }
    
    CreativePoints {
        
        id: obj_0
    
        property var input_0: extract_part_hitro_8.output /* moved to singletones */
        property var input_1: extract_part_hitro_9.output /* moved to singletones */
        property var input_2: extract_part_hitro_10.output /* moved to singletones */
        colors: shapes2colors_6.output /* moved to singletones */
        radius: 0.25
        positions: []
        text: scene_obj.text+' - точки'
        shader: [final_extras_arr]
        DeferredCalc {
            
            id: obj_1
        
            targetProperty: "positions"
            func: combine_arrays
            params: [parent.input_0,parent.input_1,parent.input_2]
        }
    }
    
    CreativeTrimesh {
        
        id: obj_2
    
        property var input_0: extract_part_hitro_8.output /* moved to singletones, second use */
        property var input_1: extract_part_hitro_9.output /* moved to singletones, second use */
        property var input_2: extract_part_hitro_10.output /* moved to singletones, second use */
        colors: shapes2colors_6.output /* moved to singletones, second use */
        flat: true
        indices: combine_15.output /* by qml-xtract.cm2 */
        text: scene_obj.text+' - поверхность'
        positions: []
        shader: [final_extras_arr]
        DeferredCalc {
            
            id: obj_4
        
            targetProperty: "positions"
            func: combine_arrays
            params: [parent.input_0,parent.input_1,parent.input_2]
        }
    
        Item {
            //generated by auto_qml_obj
            id: combine_15
        
            property var output: []
            property var input_0: extract_part_hitro_12.output /* moved to singletones */
            property var input_1: extract_part_hitro_13.output /* moved to singletones */
            property var input_2: extract_part_hitro_14.output /* moved to singletones */
            DeferredCalc {
                
                id: obj_3
            
                targetProperty: "output"
                func: func_combine
                params: [parent.input_0,parent.input_1,parent.input_2]
            }
        }
    }
    
    function combine_arrays () {
      
        // ну упаковка.. дали набор одномерных массивов - выдай из них сборку, один массив во viewlang-упаковке
        // todo можно сделать ускоренную версию для 3х входов - var arr1=arguments[0]; и т.д.
        for (var i=0; i<arguments.length; i++,index++)
          if (typeof(arguments[i]) == "undefined") return []; // ну такая защита.. если какой-то аргумент-массив еще не рассчитался.. (бывали случаи)
        
        var len1 = arguments[0].length;
        var acc = new Float32Array(len1 * arguments.length);
        var index = 0;
        for (var line=0; line<len1; line++)
          for (var i=0; i<arguments.length; i++,index++)
            acc[index] = ( arguments[i][line] || 0 );
    
        return acc;
    
    }
    
    ///////////////// singletones!
    
    Item {
        //generated by auto_qml_obj
        id: parse_vrml_4
    
        property var output: func_parse_vrml( input_0 )
        property var input_0: obj_5.output /* by qml-xtract.cm2 */
    
        TextLoader2 {
            
            id: obj_5
        
            property var input_0: resolved_3.output /* by qml-xtract.cm2 */
        
            Item {
                //generated by auto_qml_obj
                id: resolved_3
            
                property var output: func_resolved( input_0 )
                property var input_0: param_emachine_afile.val
            }
        }
    }
    
    Item {
        //generated by auto_qml_obj
        id: vrml2shapes_5
    
        property var output: func_vrml2shapes( input_0 )
        property var input_0: parse_vrml_4.output /* moved to singletones */
    }
    
    Item {
        //generated by auto_qml_obj
        id: shapes2colors_6
    
        property var output: func_shapes2colors( input_0 )
        property var input_0: vrml2shapes_5.output /* moved to singletones */
    }
    
    Item {
        //generated by auto_qml_obj
        id: shapes2xyz_7
    
        property var output: func_shapes2xyz( input_0 )
        property var input_0: vrml2shapes_5.output /* moved to singletones, second use */
    }
    
    Item {
        //generated by auto_qml_obj
        id: extract_part_hitro_8
    
        property var output: func_extract_part_hitro( input_0,input_1,input_2,input_3 )
        property var input_0: shapes2xyz_7.output /* moved to singletones */
        property var input_1: "x"
        property var input_2: 0
        property var input_3: ''
    }
    
    Item {
        //generated by auto_qml_obj
        id: extract_part_hitro_9
    
        property var output: func_extract_part_hitro( input_0,input_1,input_2,input_3 )
        property var input_0: shapes2xyz_7.output /* moved to singletones, second use */
        property var input_1: "y"
        property var input_2: 1
        property var input_3: ''
    }
    
    Item {
        //generated by auto_qml_obj
        id: extract_part_hitro_10
    
        property var output: func_extract_part_hitro( input_0,input_1,input_2,input_3 )
        property var input_0: shapes2xyz_7.output /* moved to singletones, second use */
        property var input_1: "z"
        property var input_2: 2
        property var input_3: ''
    }
    
    Item {
        //generated by auto_qml_obj
        id: shapes2indices_11
    
        property var output: func_shapes2indices( input_0 )
        property var input_0: vrml2shapes_5.output /* moved to singletones, second use */
    }
    
    Item {
        //generated by auto_qml_obj
        id: extract_part_hitro_12
    
        property var output: func_extract_part_hitro( input_0,input_1,input_2,input_3 )
        property var input_0: shapes2indices_11.output /* moved to singletones */
        property var input_1: "i1"
        property var input_2: 0
        property var input_3: ''
    }
    
    Item {
        //generated by auto_qml_obj
        id: extract_part_hitro_13
    
        property var output: func_extract_part_hitro( input_0,input_1,input_2,input_3 )
        property var input_0: shapes2indices_11.output /* moved to singletones, second use */
        property var input_1: "i2"
        property var input_2: 1
        property var input_3: ''
    }
    
    Item {
        //generated by auto_qml_obj
        id: extract_part_hitro_14
    
        property var output: func_extract_part_hitro( input_0,input_1,input_2,input_3 )
        property var input_0: shapes2indices_11.output /* moved to singletones, second use */
        property var input_1: "i3"
        property var input_2: 2
        property var input_3: ''
    }
    
    /////////////// runtime extras!
    
    property var external_extras_manager: new Object({output:[]})
    property var final_extras_arr: external_extras_manager.output.concat( local_extras_manager.output )
    property var local_extras_manager: obj_extras_manager
    ExtrasManager {
        
        id: obj_extras_manager
    
        title: scene_obj.isRoot ? 'Добавки' : scene_obj.text+'&nbsp;-&nbsp;Добавки'
        input_1: []
    }
    
    ///////////////// functions!
    
    function func_resolved (u) {
      if (Array.isArray(u)) return Qt.resolvedUrl( u[0] );
      
     return Qt.resolvedUrl( u );
    }
    function func_parse_vrml (vrml_lines_text) {
      console.time("parse_vrml");
      var STATES = [[]];
    
      var perliner = function (line) {
        var indent = line.match(/^(  )*/)[0].length / 2;
    
        lines = line.replace(/(\S+)\s*([\}\]])/g, '$1\n$2').split(/\r?\n+/g);
    
        lines.forEach(function (line) {
          while (true) {
            if (line.match(/^[^\[]+\{/)) {
              var key = line.match(/^\s*([^\]]+?)\s*\{/)[1];
              line = line.replace(/(.*?)\{/, '');
              
              //console.log('OBJ', key);
              var obj = { };
              if (Array.isArray(STATES[0])) {
                obj.$TYPE = key;
                STATES[0].push(obj);
              } else {
                STATES[0][key] = obj;
              }
              STATES.unshift(obj);
    
            } else if (line.match(/^[^\{]+\[/)) {
              var key = line.match(/^\s*([^\{]+?)\s*\[/)[1];
              line = line.replace(/(.*?)\[/, '');
              
              //console.log('ARR', key);
              var arr = []; 
              if (Array.isArray(STATES[0])) {
                arr.$TYPE = key;
                STATES[0].push(arr);
              } else {
                STATES[0][key] = arr;
              }
              STATES.unshift(arr);
    
            } else if (line.match(/^\s*\}/)) {
              //console.log('CLOSEOBJ', '}');
              line = line.replace(/^\s*\}/, '')
    
              // TODO check
              STATES.shift();
    
            } else if (line.match(/^\s*\]/)) {
              //console.log('CLOSEARR', ']');
              line = line.replace(/^\s*\]/, '')
    
              // TODO check
              STATES.shift();
    
            } else if (line.match(/[\{\}\[\]]/)) {
              console.error('Mismatched parens:\n', line);
              return [];
              //process.exit(1);
    
            } else if (line.match(/^\s*(#|$)/)) {
              break;
            
            } else if (Array.isArray(STATES[0])) {
              var entries = line.split(/\s+|\s*\,\s*/g).filter(function (a) {
                return a;
              }).map(function (a) {
                //var arg = a.replace(/^\s+|\s+$/g, '');
                var arg=a; // parse-float-у вроде не должны пробелы то мешать..
                var p = parseFloat(arg); if (!isNaN(p)) return p;
    //            if (String(parseFloat(arg)) == arg) {
    //              return parseFloat(arg);
    //            }
                return arg;
              });
              STATES[0].push.apply(STATES[0], entries);
              line = '';
            
            } else if (line.match(/^\s*\w+/)) {
              var key = line.match(/^\s*(\w+)/)[1];
              line = line.replace(/^\s*(\w+)/, '');
    
              var entries = line.split(/\s+|\s*\,\s*/g).filter(function (a) {
                return a;
              }).map(function (a) {
                //var arg = a.replace(/^\s+|\s+$/g, '');
                var arg=a;
                var p = parseFloat(arg); if (!isNaN(p)) return p;            
    //            if (String(parseFloat(arg)) == arg) {
    //              return parseFloat(arg);
    //            }
                return arg;
              });
              STATES[0][key] = entries;
              line = '';
    
              //console.log('PROP', key, entries);
    
            } else {
              break;
            }
          }
        });
      }
        
      var vrml_lines_arr = vrml_lines_text.split(/\n/);
      for (var i=0; i<vrml_lines_arr.length; i++ )
      {
        perliner( vrml_lines_arr[i] );
      }
      console.timeEnd("parse_vrml");
      return STATES[0];
    }
    function func_vrml2shapes (vrml) {
      return vrml.filter( function(rec) { return rec.$TYPE == "Shape" } );
    }
    function func_shapes2colors (shapes) {
      var acc = [];
      
      var qq = function (s,acc) { // s = shape
        if (!s) { console.error("getshapecolorsarr: input is false!"); return acc; }
        var c = s.Appearance.Material.diffuseColor;
        var coords = s.IndexedFaceSet.Coordinate.point;
        for (var j=0; j<coords.length; j+=3) {
           acc.push( c[0] );
           acc.push( c[1] );
           acc.push( c[2] );
         }
        return acc;
      }
      
      shapes.forEach( function(s) {
        qq( s, acc )
      })
      
      return acc;
    }
    function func_shapes2xyz (shapes) {
      var acc = { x:[], y:[], z:[] };
      
      shapes.forEach( function(s) {
        var pts = s.IndexedFaceSet.Coordinate.point;
        for (var j=0; j< pts.length; j+= 3) {
          acc.x.push( pts[j] );
          acc.y.push( pts[j+1] );
          acc.z.push( pts[j+2] );
        }
      })
      
      return acc;
    }
    function func_extract_part_hitro (obj,name,index,realname) {
      if (Array.isArray(obj)) {
         if (name == "*") // сообразно index всегда 0, но зато realname нечто настоящее
           return obj[ parseInt(realname) ];
         else
           return obj[index];
      }
      // ну надеемся что obj это хеш
        
      if (name == "*")
        return obj[realname] || [];
          
      return obj[name] || [];
    }
    function func_shapes2indices (shapes) {
      var acc = { i1:[], i2:[], i3:[] };
      var i0 = 0;
      
      shapes.forEach( function(s) {
        var pts = s.IndexedFaceSet.coordIndex;
    
        for (var j=0; j< pts.length; j+= 4) {
          acc.i1.push( pts[j]+i0 );
          acc.i2.push( pts[j+1]+i0 );
          acc.i3.push( pts[j+2]+i0 );
        }
        
        i0 += s.IndexedFaceSet.Coordinate.point.length/3;
      })
      
      return acc;
    }
    function func_combine () {
      return combine_arrays.apply( this,arguments );
    }
}
