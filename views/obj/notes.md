Задача - нарисовать поверхность, записанную в obj-файле.
По типу как с множествами достижимости.
При этом визуальные фильтры в программе м.д. - признаны полезными.

Оказалось, что объект, возвращаемый используемым нами three-js парсером obj - хитрый.
Он на первом уровне содержит библиотеку данных, а уже во вложенных - объекты с развернутыми данными.
Т.е. чтобы нарисовать поверхность - надо идти в первый объект и там ее вытаскивать.

Так, с треугольниками разобрались. Ну ходим и вытаскиваем. Теперь непотянка какая-то с нормалями - с этим будем разбираться.
Причем неясно и что там у Сержа в данных, и что там у нас.. и трижс непонятно как работает, и непонятно как работает и выьюланга
Возможно - надо будет порисовать у нас нормали. А спросим ка Сержа.

И потом надо с фильтрами разобраться, что там им на вход подается

***
Нормали.. целая история. В wavefont obj написано что нормали указываются на уровне фейсов
https://en.wikipedia.org/wiki/Wavefront_.obj_file#Vertex_normal_indices

Threejs имеет возможности
1. https://threejs.org/docs/#api/en/materials/Material.flatShading да-нет.
Если нет, то он на нормали не обращает внимание при раскраске.

2.
- принимать неиндексированный меш (triangle soup) и без нормалей,
и тогда вызывается computeVertexNormals которое каждому треугольнику каждой его вершине
выставляет нормаль посчитанную как перпендикуляр к треугольнику
- принимать индексированный меш без нормалей,
тогда он рассчитывает нормали на вершинах как средние по треугольникам,
которые опираются на вершину
https://github.com/mrdoob/three.js/blob/master/src/core/BufferGeometry.js#L718

Внимание на то, что индексированный меш в trhee-js (и видимо в webgl) влияет на все аттрибуты.
Т.е. индексы говорят и про позиции, и про цвета, и про нормали..

Если же при это мы внешним образом к threejs задаем свои нормали, то они считаются сообразно вершинными.
Как при этом происходит рендеринг если меш индексированный? Ну вот, берется нормаль для вершины, указанной индексом.

Это вообще говоря странно. Потому что как мы будем использовать общую вершину для треугольников
и разные нормали на ней? Получается что никак, и это видимо их ограничение.

Вот здесь об этом прекрасно пишут..
https://webglfundamentals.org/webgl/lessons/webgl-indexed-vertices.html
Также там кстати говорят об ограничении 65 тыс на номера индексов. Это не очень то и весело.
Может threejs умеет с этим разбираться, само разбивает на несколько вызовов? (хаха)

Вот люди переживают что убрали индексы из обж-лоадера..
https://github.com/mrdoob/three.js/issues/11898

У обжа беда, и об этом пишут, что у них 3 разных индексных буфера - для координат, текстур, и нормалей.
А у вебжль-я только 1. Вот.

Итак, о чем это я. Общая картина:
1. WEbgl 1 индексный буфер, т.е. едино нумеруемый список нормалей и вершин должен быть.
Т.е. никаких вам штук как в обже, когда у треугольника вершины общие с другими, а нормали на них - разные.
Да и Бог с ним.
2. Я использовал three-js obj-загрузчик. Он само-распаковывает индексируемые треугольники.
И как-то переносит встроенные нормали - не знаю как, но получается фигня.
3. В three-js есть нормальный расчет нормалей, но для учета соседних треугольников нужны индексы.
4. Есть flat-режим, он что-то там отменяет раскраску.. но ему тоже нужна нормаль.. но он видимо как-то 
не интерполирует между вершинами.. хз.. ладно, будем считать что я не понимаю, как ведет себя threejs
когда ему не дали нормали.. может он их сам рассчитывает..

Вот. Тут пишут понятно. http://learnwebgl.brown37.net/model_data/model_surface_normals.html
flat shading это когда 1 нормаль на треугольник.

Итак, если мы воссоздаем нормали с потерянынми индексами (а это так если использовать текущий objloader v1)
- мы получаем тот же эффект. вот почему не видно разницы, когда я переключаюсь между flat shading и не flat. Нормали посчитаны индивидуально уже.

ИтогО, что я теперь вижу. Мы можем
1. Пробовать использовать нормали которые идут в обж. Но то что я попробовал на обжах Сержа - там треш, и это такие вот там нормали.
2. Считать самим. Тогда это надо делать до этапа разделения индексов. Т.е. либо при загрузке, либо требовать данные с индексами
и вызывать computeVertextNormals (что во вьюланге то же самое что normals не указать, а indices указать).

Что мы имеем
1 Наркоманский загрузкчик из транка threejs
https://github.com/mrdoob/three.js/blob/dev/examples/js/loaders/OBJLoader.js
2 Новый полунаркоманский загрузчик
https://github.com/mrdoob/three.js/blob/master/examples/jsm/loaders/obj2/worker/parallel/OBJLoader2Parser.js
который вроде как с индексами уже дружит

3 Экстремально простой загрузчик https://github.com/mikolalysenko/parse-obj/blob/master/parse-obj.js

4 https://github.com/frenchtoast747/webgl-obj-loader
какой-то средний загрузчик но на ts и непонятно что с нормалями..

Мелкий загрузчик отработал норм.

----
Оказалось таки да. Если делаем "свой" (threejs) расчет нормалей то все ок. И рисуется коряво - но из=за абы как ориентированных
треугольников. Проверка - в Meshlab сделать Filters -> Normals, Curvatures and Orientation -> Reorent all faces coherently
и экспортировать как новый обж - тогда он у нас показывается красиво.

На будущее можно вставить перестройку индексов в js - (суть переориентацию треугольников).

И да, почему-то индексные буферы большие работают. Ну у меня хром, линукс, видяха 1030.

====
Пока искал как поворачивать треугольники в js наше вот это https://meshoptimizer.org/ там всякие оптимизации мешей. Ну ладно.

Дальше что.
- оптимизировать обж-загрузчик, благо он простой
(пусть выдает сразу x y z колонки и index например общий.. ну или i1 i2 i3.. ладно уж)
- разобраться с параметрами шейдеров
в том числе с автомасштабом, который может следует вынести наружу
- хорошо бы в шейдерах таки сделать ручное управление программой
- опубликовать для на гитхаб чтобы пользоваться можно было
- таки идти в сторону слоев/синема сцен

***********************************************************************
- title: Примеры
  variants:
    - title: dubins_-05_m_l_0_pi_scaled_3.5
      params:
        afile:
          - 'http://viewlang.ru/objs/v2/dubins_-05_m_l_0_pi_scaled_3.5.obj'
    - title: dubins_-1_m_l_0_3pi_scaled_3.5
      params:
        afile:
          - 'http://viewlang.ru/objs/v2/dubins_-1_m_l_0_3pi_scaled_3.5.obj'
    - title: dubins_-1_m_l_0_3pi_scaled_3.5_reore
      params:
        afile:
          - 'http://viewlang.ru/objs/v2/dubins_-1_m_l_0_3pi_scaled_3.5_reore.obj'
